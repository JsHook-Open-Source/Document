# memory

If your model cannot input QX driver, you can use this interface to directly read and write the target application memory in kernel mode

## memory.getModuleBase(libname)

Get the memory address of a certain so shared library, which can be used for memory offset calculation

`Parameter`:

`libname`: string

`Return value`: string

## memory.readDword(address)

Get the integer value of the memory address

`Parameter`:

`address`: string

`Return value`: long

## memory.readFloat(address)

Get the floating point value of the memory address

`Parameter`:

`address`: string

`Return value`: float

## memory.writeDword(address,value)

Write the integer value of the memory address

`Parameter`:

`address`: string

`value`: long

`Return value`: int

## memory.writeFloat(address,value)

Write floating point value to memory address

`Parameters`:

`address`: string

`value`: float

`Return value`: int

## Sample script

First download the target application for practice [https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida.apk](https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida.apk)

And the corresponding `dump.cs` file [https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida_dump.cs](https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida_dump.cs)

The `Learn.Frida_dump.cs` file mainly analyzes `public class FieldTest: MonoBehaviour`Method here

The following is a script example. In the script, frida is used to find the memory base address in non-kernel mode. Of course, you can use other methods to find the memory base address. Click the `ShowResult` button to display an input box for entering the current `staticA` value to search for the memory address

```javascript
//Memory scan
const memoryScan = (m, pattern, call) => {
Memory.scan(m.base, m.size, pattern, {
onMatch(address, size) {
call(address)
return 'stop';
},
onComplete() {
}
});
}

function getRandomInt(min, max) {
return Math.floor(Math.random() * (max - min + 1)) + min;
}

//Start using the kernel
if (runtime.isKernel) {

console.log('kernel start')

const time = setInterval(() => {
const il2cpp = memory.getModuleBase('libil2cpp.so')
if (il2cpp) {
clearInterval(time)
console.log('il2cpp', il2cpp)

//Read/modify data
setInterval(() => {
const newval = getRandomInt(100, 999)
console.log('newval', newval)
memory.writeDword('0x7e3fe30c30', newval)

const memory_staticA = memory.readDword('0x7e3fe30c30')
console.log('staticA', memory_staticA)
}, 3000)
}
}, 100)
} else {

//In non-kernel mode, find the memory base address of the variable through frida, you can also get it through other methods

const time = setInterval(() => {
const addr = Module.findBaseAddress('libil2cpp.so')
if (addr) {
clearInterval(time)
console.log('libil2cpp ok')
//il2cpp module address is dynamic
const il2cpp = ptr(addr)
console.log('il2cpp', il2cpp)
//This 0x667F14 is an offset, fixed, pointing to the ShowResult method
Interceptor.attach(il2cpp.add(0x667F14), {
onEnter: function (args) {
//Current instance
const instance = args[0]

//Enter the current value of staticA to search memory
dialog.input('search_val', {
ok: function (res) {

//Get the search range
const range = Process.findRangeByAddress(instance)

//Search condition
const pattern = ptr(parseInt(res)).toMatchPattern().replace(' 00 00 00 00', '')

memoryScan(range, pattern, (address) => {
//Variable memory address
console.log('staticA_address', address)

Java.perform(function () {
//Variable memory value, read using memory interface
const staticA = memory.readDword(String(address))
console.log('staticA', staticA)

//Modify, modify using memory interface
memory.writeDword(String(address), 1000)
})
})
},
cancel: function () {
}
}, '')
},
onLeave: function (retval) {
}
})
}
}, 100)

}

```
