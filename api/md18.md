# kernel

The interface used in kernel mode requires the support of fridamod framework. `runtime.isKernel` is used to determine whether it is in kernel mode

In kernel mode, the target application will not be injected, but the spectator process will be cloned and frida will be executed in the spectator process. Only the API provided by jshook can be used in the script, and the hook-related API is invalid

## kernel.getModuleBase(libname)

Get the memory address of a certain so shared library, which can be used for memory offset calculation

`Parameter`:

`libname`: string

`Return value`: string

## kernel.readDword(address)

Get the integer value of the memory address

`Parameter`:

`address`: string

`Return value`: long

## kernel.readFloat(address)

Get the floating point value of the memory address

`Parameter`:

`address`: string

`Return value`: float

## kernel.writeDword(address,value)

Write the integer value of the memory address

`Parameter`:

`address`: string

`value`: long

`Return value`: int

## kernel.writeFloat(address,value)

Write floating point value to memory address

`Parameter`:

`address`: string

`value`: float

`Return value`: int

## Sample script

First download the target application for practice [https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida.apk](https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida.apk)

And the corresponding `dump.cs` file [https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida_dump.cs](https://github.com/JsHookApp/Download/releases/download/files/Learn.Frida_dump.cs)

The `Learn.Frida_dump.cs` file mainly analyzes `public class FieldTest: MonoBehaviour`Method here

The following is a script example. In the script, frida is used to find the memory base address in non-kernel mode. Of course, you can use other methods to find the memory base address, and then modify the variable value in kernel mode. Click the `ShowResult` button to display an input box for entering the current `staticA` value to search for the memory address

```javascript
//Memory scan
const memoryScan = (m, pattern, call) => {
Memory.scan(m.base, m.size, pattern, {
onMatch(address, size) {
call(address)
return 'stop';
},
onComplete() {
}
});
}

function getRandomInt(min, max) {
return Math.floor(Math.random() * (max - min + 1)) + min;
}

//Start using the kernel
if (runtime.isKernel) {

console.log('kernel start')

const time = setInterval(() => {
const il2cpp = kernel.getModuleBase('libil2cpp.so')
if (il2cpp) {
clearInterval(time)
console.log('il2cpp', il2cpp)

//Read/modify data
setInterval(() => {
const newval = getRandomInt(100, 999)
console.log('newval', newval)
kernel.writeDword('0x7e3fe30c30', newval)

const kernel_staticA = kernel.readDword('0x7e3fe30c30')
console.log('staticA', kernel_staticA)
}, 3000)
}
}, 100)
} else {

//Find the memory base address of the variable through frida in non-kernel mode, you can also get it through other methods

const time = setInterval(() => {
const addr = Module.findBaseAddress('libil2cpp.so')
if (addr) {
clearInterval(time)
console.log('libil2cpp ok')
//il2cpp module address is dynamic
const il2cpp = ptr(addr)
console.log('il2cpp', il2cpp)
//This 0x667F14 is an offset, fixed, pointing to the ShowResult method
Interceptor.attach(il2cpp.add(0x667F14), {
onEnter: function (args) {
//Current instance
const instance = args[0]

//Enter the current value of staticA to search memory
dialog.input('search_val', {
ok: function (res) {

//Get the search range
const range = Process.findRangeByAddress(instance)

//Search condition
const pattern = ptr(parseInt(res)).toMatchPattern().replace(' 00 00 00 00', '')

memoryScan(range, pattern, (address) => {
//Variable memory address
console.log('staticA_address', address)

//Variable memory value
const staticA = ptr(address).readInt()
console.log('staticA', staticA)

//Modify
ptr(address).writeInt(1000)
})
},
cancel: function () {
}
}, '')
},
onLeave: function (retval) {
}
})
}
}, 100)

}

```
